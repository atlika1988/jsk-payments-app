import pandas as pd
import re
from datetime import datetime
from dataclasses import dataclass
from typing import Optional, List, Iterable, Tuple

from sqlalchemy import (
    create_engine, Column, Integer, String, DateTime, Numeric, Text, ForeignKey
)
from sqlalchemy.orm import declarative_base, relationship, Session


Base = declarative_base()


class Apartment(Base):
    __tablename__ = "apartments"
    id = Column(Integer, primary_key=True)
    number = Column(Integer, nullable=False, index=True)
    owner_name = Column(String, nullable=True)


class Payment(Base):
    __tablename__ = "payments"
    id = Column(Integer, primary_key=True)
    apartment_id = Column(Integer, ForeignKey("apartments.id"), nullable=False)
    date = Column(DateTime, nullable=False)
    amount = Column(Numeric(12, 2), nullable=False)
    description = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)

    apartment = relationship("Apartment")


class UnmatchedPayment(Base):
    __tablename__ = "unmatched_payments"
    id = Column(Integer, primary_key=True)
    date = Column(DateTime, nullable=False)
    amount = Column(Numeric(12, 2), nullable=False)
    description = Column(Text, nullable=False)
    raw_info = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)


@dataclass
class ParsedPayment:
    date: datetime
    amount: float
    description: str
    guessed_apartment_number: Optional[int] = None
    apartment_id: Optional[int] = None


# --------------------- Чтение выписки -----------------------------

def read_sber_statement_excel(path: str) -> pd.DataFrame:
    df = pd.read_excel(path, header=9, dtype=str)

    df = df.rename(columns={
        "Дата проводки": "date",
        "Сумма": "amount",
        "Назначение платежа": "description",
    })

    df = df[["date", "amount", "description"]]
    df = df.dropna(how="all")

    df["date"] = pd.to_datetime(df["date"], errors="coerce")
    df["amount"] = (
        df["amount"]
        .str.replace(" ", "", regex=False)
        .str.replace(",", ".", regex=False)
    )
    df["amount"] = pd.to_numeric(df["amount"], errors="coerce")
    df["description"] = df["description"].astype(str)

    df = df.dropna(subset=["date", "amount"])

    return df


# ---------------------- Логика определения квартиры ----------------------

def guess_apartment_number(description: str) -> Optional[int]:
    if not description:
        return None

    text = description.lower()

    patterns = [
        r"кв\.?\s*(\d+)",
        r"квартира\s+(\d+)",
        r"кв-?(\d+)"
    ]

    for pat in patterns:
        m = re.search(pat, text, flags=re.IGNORECASE)
        if m:
            try:
                return int(m.group(1))
            except:
                pass

    return None


def parse_statement_to_payments(df: pd.DataFrame) -> List[ParsedPayment]:
    result = []

    for _, row in df.iterrows():
        p = ParsedPayment(
            date=row["date"],
            amount=float(row["amount"]),
            description=row["description"],
            guessed_apartment_number=guess_apartment_number(row["description"]),
        )
        result.append(p)

    return result


# ---------------------- Привязка к квартирам -------------------------

def attach_apartment_ids(
    payments: Iterable[ParsedPayment],
    session: Session
) -> Tuple[List[ParsedPayment], List[ParsedPayment]]:

    apartments = session.query(Apartment).all()
    by_number = {a.number: a.id for a in apartments}

    matched = []
    unmatched = []

    for p in payments:
        if p.guessed_apartment_number in by_number:
            p.apartment_id = by_number[p.guessed_apartment_number]
            matched.append(p)
        else:
            unmatched.append(p)

    return matched, unmatched


# ---------------------- Сохранение в БД -------------------------

def save_payments_to_db(
    session: Session,
    matched: List[ParsedPayment],
    unmatched: List[ParsedPayment]
):
    for p in matched:
        session.add(Payment(
            apartment_id=p.apartment_id,
            date=p.date,
            amount=p.amount,
            description=p.description
        ))

    for p in unmatched:
        session.add(UnmatchedPayment(
            date=p.date,
            amount=p.amount,
            description=p.description,
            raw_info=str(p.guessed_apartment_number)
        ))

    session.commit()


# ---------------------- Главная функция импорта -------------------------

def import_statement(path: str, session: Session):
    df = read_sber_statement_excel(path)
    parsed = parse_statement_to_payments(df)
    matched, unmatched = attach_apartment_ids(parsed, session)
    return matched, unmatched
